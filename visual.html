<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Seafoam E‑Card Visual Editor with Templates</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&
family=Roboto:wght@400;700&family=Open+Sans:wght@400;700&
family=Lora:wght@400;700&family=Montserrat:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        padding: 1rem;
        background: #f0f0f0;
        font-family: "Poppins", sans-serif;
      }
      h1 {
        text-align: center;
        margin-bottom: 1rem;
      }
      #workspace {
        display: flex;
        gap: 1rem;
      }
      #paper {
        position: relative;
        flex: 1;
        background: #fff8e7;
        border: 2px solid #82c9a1;
        height: 700px;
        overflow: auto;
      }
      /* assets panel & tabs */
      #assets {
        width: 300px;
        background: #fafafa;
        border: 2px solid #ddd;
        display: flex;
        flex-direction: column;
      }
      #assetTabs {
        display: flex;
      }
      #assetTabs button {
        flex: 1;
        padding: 0.5rem;
        border: none;
        cursor: pointer;
        background: #ddd;
        font-weight: 600;
      }
      #assetTabs button.active {
        background: #fff;
        border-bottom: 2px solid #fff;
      }
      .assetPanel {
        height: 350px;
        margin-bottom: 16px;
        overflow: auto;
        padding: 0.5rem;
        display: none;
      }
      .assetPanel.active {
        display: block;
      }
      /* templates panel */
      #assetsTemplates .templateItem {
        margin-bottom: 1rem;
        cursor: pointer;
        border: 1px solid #ccc;
        border-radius: 6px;
        overflow: hidden;
        text-align: center;
      }
      #assetsTemplates .templateItem .preview {
        position: relative;
        width: 100%;
        height: 300px;
        background: #fff8e7;
        border-bottom: 1px solid #ccc;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #assetsTemplates .templateItem .preview .placeholder {
        border: 2px dashed #aaa;
        width: 80%;
        height: 60%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        color: #666;
      }
      #assetsTemplates .templateItem .preview .demoText {
        position: absolute;
        bottom: 10px;
        left: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.8);
        padding: 6px;
        font-size: 14px;
        color: #333;
        text-align: center;
      }
      #assetsTemplates .templateItem .preview .sticker {
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: 36px;
      }
      #assetsTemplates .templateItem span {
        display: block;
        padding: 0.5rem;
        background: #f9f9f9;
        font-weight: 600;
      }
      /* images panel */
      #assetsImages input {
        width: 100%;
        margin-bottom: 0.5rem;
        padding: 0.25rem;
      }
      #assetsImages button {
        width: 100%;
        margin-bottom: 1rem;
        padding: 0.5rem;
        background: #60a085;
        border: none;
        color: #fff;
        cursor: pointer;
        border-radius: 4px;
      }
      #assetList img {
        width: 100%;
        margin-bottom: 0.5rem;
        cursor: grab;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      /* emojis panel */
      #assetEmojis .emojiItem {
        font-size: 1.5rem;
        display: inline-block;
        padding: 0.25rem;
        margin: 0.25rem;
        cursor: grab;
      }

      /* Layers panel */
      #layersPanel {
        height: 350px;
        margin-top: 16px;
        overflow: auto;
        border: 1px solid #ccc;
        border-radius: 6px;
        background: #fff;
        padding: 0.5rem;
      }
      #layersPanel h4 {
        margin: 0 0 0.5rem;
        font-size: 0.9rem;
        font-weight: 600;
        color: #155f46;
      }
      #layersList {
        list-style: none;
        margin: 0;
        padding: 0;
        max-height: 200px;
        overflow-y: auto;
      }
      .layerItem {
        display: flex;
        align-items: center;
        padding: 4px;
        margin-bottom: 2px;
        background: #f9f9f9;
        border: 1px solid #ddd;
        border-radius: 4px;
        cursor: grab;
      }
      .layerIcon {
        width: 16px;
        height: 16px;
        margin-right: 6px;
        flex-shrink: 0;
      }
      .layerLabel {
        flex: 1;
        font-size: 0.85rem;
        color: #333;
      }
      .layerItem.dragging {
        opacity: 0.5;
      }
      /* toolbars & handles */
      #toolbar,
      #shapeMenu,
      #textToolbar,
      #shapeToolbar,
      #fontMenu {
        position: absolute;
        display: none;
        z-index: 2000;
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      }
      #toolbar {
        padding: 0.25rem;
        display: flex;
        gap: 0.5rem;
      }
      #toolbar button {
        width: 36px;
        height: 36px;
        border: none;
        border-radius: 50%;
        background: #a8e6cf;
        cursor: pointer;
      }
      #toolbar button:hover {
        background: #76c69c;
      }
      #toolbar button img {
        width: 20px;
        height: 20px;
      }
      #shapeMenu {
        padding: 0.25rem;
        display: flex;
        gap: 0.5rem;
        border-radius: 8px;
      }
      #shapeMenu button {
        width: 32px;
        height: 32px;
        border: none;
        border-radius: 4px;
        background: #a8e6cf;
        cursor: pointer;
      }
      #shapeMenu button:hover {
        background: #76c69c;
      }
      #textToolbar,
      #shapeToolbar {
        padding: 0.25rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        white-space: nowrap;
      }
      #textToolbar button,
      #shapeToolbar button {
        background: transparent;
        border: none;
        cursor: pointer;
        font-size: 1.1rem;
      }
      #textToolbar button img,
      #shapeToolbar button img {
        width: 20px;
        height: 20px;
      }
      #textToolbar input,
      #shapeToolbar input {
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 2px;
      }
      #shapeToolbar input[type="number"] {
        width: 3rem;
      }
      #shapeToolbar input[type="range"] {
        width: 5rem;
      }
      .tb-delete {
        font-size: 1.2rem;
        color: #c0392b;
        padding: 0 6px;
        cursor: pointer;
      }
      .tb-delete:hover {
        color: #e74c3c;
      }
      #fontMenu {
        position: absolute;
        top: 100%;
        left: 0;
        max-height: 200px;
        width: 150px;
        overflow-y: auto;
      }
      #fontMenu .fontOption {
        display: block;
        width: 100%;
        padding: 6px 8px;
        text-align: left;
        background: transparent;
        border: none;
        cursor: pointer;
        font-size: 0.95rem;
      }
      #fontMenu .fontOption:hover {
        background: #f0f0f0;
      }
      .resize-handle,
      .vertex-handle,
      .rotate-handle {
        display: none;
      }
      .resize-handle {
        position: absolute;
        width: 10px;
        height: 10px;
        background: #fff;
        border: 1px solid #60a085;
      }
      .handle-nw {
        cursor: nwse-resize;
        top: -5px;
        left: -5px;
      }
      .handle-ne {
        cursor: nesw-resize;
        top: -5px;
        right: -5px;
      }
      .handle-sw {
        cursor: nesw-resize;
        bottom: -5px;
        left: -5px;
      }
      .handle-se {
        cursor: nwse-resize;
        bottom: -5px;
        right: -5px;
      }
      .vertex-handle {
        position: absolute;
        width: 12px;
        height: 12px;
        background: #fff;
        border: 2px solid #60a085;
        border-radius: 50%;
        cursor: move;
        margin: -6px;
      }
      .rotate-handle {
        position: absolute;
        top: -20px;
        left: 50%;
        transform: translateX(-50%);
        width: 12px;
        height: 12px;
        background: #fff;
        border: 2px solid #60a085;
        border-radius: 50%;
        cursor: grab;
      }
      .element.selected .resize-handle,
      .element.selected .rotate-handle,
      .shape-wrapper.selected .vertex-handle {
        display: block !important;
      }
      /* content */
      .element,
      .shape-wrapper {
        position: absolute;
        user-select: none;
        transform-origin: center;
      }
      .text-wrapper {
        position: relative;
      }
      .text-content {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        padding-top: 20px;
        overflow: auto;
        outline: none;
        cursor: text;
      }
      .shape-rect {
        background: transparent;
      }
      .shape-circle {
        background: transparent;
        border-radius: 50%;
      }
    </style>
  </head>
  <body>
    <h1>Visual E-card Editor</h1>
    <div id="workspace">
      <div id="paper"></div>
      <div id="assets">
        <div id="assetTabs">
          <button id="tabTemplates" class="active">Templates</button>
          <button id="tabImages">Images</button>
          <button id="tabEmojis">Emojis</button>
        </div>
        <!-- Layers panel -->
        <div id="layersPanel">
          <h4>Layers</h4>
          <ul id="layersList"></ul>
        </div>
        <div id="assetsTemplates" class="assetPanel active">
          <div class="templateItem" data-template="birthday">
            <div class="preview">
              <div class="placeholder">Your Image Here</div>
              <div class="sticker">🎉</div>
              <div class="demoText">
                “Birthdays are the universe’s way of telling us to eat more
                cake.”
              </div>
            </div>
            <span>Birthday 🎂</span>
          </div>
          <div class="templateItem" data-template="thankyou">
            <div class="preview">
              <div class="placeholder" style="width: 60%; height: 50%">
                Your Image Here
              </div>
              <div class="sticker">🙏</div>
              <div class="demoText">
                “Thank you for being the reason I smile every day.”
              </div>
            </div>
            <span>Thank You 🙏</span>
          </div>
        </div>
        <div id="assetsImages" class="assetPanel">
          <input type="text" id="assetUrlInput" placeholder="Image URL" />
          <button id="assetAddBtn">Add Image</button>
          <div id="assetList"></div>
        </div>
        <div id="assetEmojis" class="assetPanel">
          <div class="emojiItem">🎉</div>
          <div class="emojiItem">🎂</div>
          <div class="emojiItem">❤️</div>
          <div class="emojiItem">😊</div>
          <div class="emojiItem">🎁</div>
          <div class="emojiItem">🌟</div>
          <div class="emojiItem">🥳</div>
          <div class="emojiItem">💌</div>
          <div class="emojiItem">🎈</div>
          <div class="emojiItem">✨</div>
        </div>
      </div>
    </div>
    <div id="toolbar">
      <button id="btnText" title="Add Text">T</button>
      <button id="btnShape" title="Add Shape">
        <img src="shapes.svg" alt="Shapes" />
      </button>
    </div>
    <div id="shapeMenu">
      <button data-shape="rect">◻</button>
      <button data-shape="circle">◯</button>
      <button data-shape="triangle">△</button>
    </div>
    <div id="textToolbar">
      <button id="tbBold"><b>B</b></button>
      <button id="tbItalic"><i>I</i></button>
      <button id="tbUnderline"><u>U</u></button>
      <button id="tbAlignLeft"><img src="align-left.svg" /></button>
      <button id="tbAlignCenter"><img src="align-center.svg" /></button>
      <button id="tbAlignRight"><img src="align-right.svg" /></button>
      <button id="tbFont">Aa</button>
      <input type="number" id="tbFontSize" min="8" max="72" />px
      <input type="color" id="tbColor" />
      <button id="tbDeleteText" class="tb-delete">×</button>
      <div id="fontMenu">
        <button class="fontOption" data-font="Poppins">Poppins</button>
        <button class="fontOption" data-font="Roboto">Roboto</button>
        <button class="fontOption" data-font="Open Sans">Open Sans</button>
        <button class="fontOption" data-font="Lora">Lora</button>
        <button class="fontOption" data-font="Montserrat">Montserrat</button>
      </div>
    </div>
    <div id="shapeToolbar">
      <input type="color" id="shapeFill" />
      <input type="color" id="shapeStroke" />
      <input type="number" id="shapeStrokeWidth" min="0" max="20" />px
      <input type="range" id="shapeOpacity" min="0" max="1" step="0.05" />
      <button id="tbDeleteShape" class="tb-delete">×</button>
    </div>
    <script>
      (function () {
        // DOM refs
        const paper = document.getElementById("paper"),
          tabTemplates = document.getElementById("tabTemplates"),
          tabImages = document.getElementById("tabImages"),
          tabEmojis = document.getElementById("tabEmojis"),
          panelTemplates = document.getElementById("assetsTemplates"),
          panelImages = document.getElementById("assetsImages"),
          panelEmojis = document.getElementById("assetEmojis"),
          templateItems = document.querySelectorAll(".templateItem"),
          assetUrlIn = document.getElementById("assetUrlInput"),
          assetAddBtn = document.getElementById("assetAddBtn"),
          assetList = document.getElementById("assetList"),
          emojiItems = document.querySelectorAll(".emojiItem"),
          toolbar = document.getElementById("toolbar"),
          shapeMenu = document.getElementById("shapeMenu"),
          textToolbar = document.getElementById("textToolbar"),
          shapeToolbar = document.getElementById("shapeToolbar"),
          fontMenu = document.getElementById("fontMenu"),
          fontOpts = fontMenu.querySelectorAll(".fontOption"),
          shapeFill = document.getElementById("shapeFill"),
          shapeStroke = document.getElementById("shapeStroke"),
          shapeStW = document.getElementById("shapeStrokeWidth"),
          shapeOp = document.getElementById("shapeOpacity"),
          tbDeleteText = document.getElementById("tbDeleteText"),
          tbDeleteShape = document.getElementById("tbDeleteShape");
        let clickX = 0,
          clickY = 0,
          selectedWrapper = null,
          selectedContent = null,
          selectedPoly = null;

        // TAB SWITCHING
        function clearTabs() {
          [tabTemplates, tabImages, tabEmojis].forEach((b) =>
            b.classList.remove("active")
          );
          [panelTemplates, panelImages, panelEmojis].forEach((p) =>
            p.classList.remove("active")
          );
        }
        tabTemplates.addEventListener("click", () => {
          clearTabs();
          tabTemplates.classList.add("active");
          panelTemplates.classList.add("active");
        });
        tabImages.addEventListener("click", () => {
          clearTabs();
          tabImages.classList.add("active");
          panelImages.classList.add("active");
        });
        tabEmojis.addEventListener("click", () => {
          clearTabs();
          tabEmojis.classList.add("active");
          panelEmojis.classList.add("active");
        });

        // TEMPLATES DATA
        const templates = {
          birthday: [
            {
              type: "title",
              text: "Happy Birthday!",
              left: "10%",
              top: "5%",
              width: "80%",
              height: "10%",
              fontSize: 32,
              color: "#155f46",
              align: "center",
            },
            {
              type: "shape",
              shape: "rect",
              left: "10%",
              top: "20%",
              width: "80%",
              height: "50%",
              fill: "transparent",
              stroke: "#aaa",
              strokeWidth: 2,
              dash: true,
            },
            {
              type: "text",
              text: "“Birthdays are the universe’s way of telling us to eat more cake.”",
              left: "10%",
              top: "75%",
              width: "80%",
              height: "15%",
              fontSize: 16,
              color: "#155f46",
              align: "center",
            },
            {
              type: "sticker",
              sticker: "🎉",
              left: "15%",
              top: "15%",
              width: 40,
              height: 40,
              rotate: 15,
            },
            {
              type: "sticker",
              sticker: "🎈",
              left: "80%",
              top: "20%",
              width: 30,
              height: 30,
              rotate: -10,
            },
            {
              type: "sticker",
              sticker: "🎂",
              left: "50%",
              top: "50%",
              width: 50,
              height: 50,
              rotate: 5,
            },
          ],
          thankyou: [
            {
              type: "title",
              text: "Thank You!",
              left: "10%",
              top: "5%",
              width: "80%",
              height: "10%",
              fontSize: 32,
              color: "#BF360C",
              align: "center",
            },
            {
              type: "shape",
              shape: "rect",
              left: "10%",
              top: "20%",
              width: "80%",
              height: "45%",
              fill: "transparent",
              stroke: "#aaa",
              strokeWidth: 2,
              dash: true,
            },
            {
              type: "text",
              text: "“Thank you for being the reason I smile every day.”",
              left: "10%",
              top: "62%",
              width: "80%",
              height: "15%",
              fontSize: 16,
              color: "#BF360C",
              align: "center",
            },
            {
              type: "sticker",
              sticker: "🙏",
              left: "15%",
              top: "15%",
              width: 40,
              height: 40,
              rotate: -20,
            },
            {
              type: "sticker",
              sticker: "💌",
              left: "85%",
              top: "25%",
              width: 30,
              height: 30,
              rotate: 10,
            },
            {
              type: "sticker",
              sticker: "✨",
              left: "60%",
              top: "55%",
              width: 35,
              height: 35,
              rotate: 25,
            },
          ],
        };

        // APPLY TEMPLATE
        function applyTemplate(name) {
          paper.innerHTML = "";
          (templates[name] || []).forEach((item) => {
            if (item.type === "shape") {
              const w = document.createElement("div");
              w.className =
                "element " +
                (item.shape === "rect" ? "shape-rect" : "shape-circle");
              Object.assign(w.style, {
                left: item.left,
                top: item.top,
                width: item.width,
                height: item.height,
              });
              if (item.dash)
                w.style.border = `${item.strokeWidth}px dashed ${item.stroke}`;
              else
                w.style.border = `${item.strokeWidth}px solid ${item.stroke}`;
              w.style.backgroundColor = item.fill;
              paper.append(w);
              initElement(w, false, null);
            } else if (item.type === "title" || item.type === "text") {
              const w = document.createElement("div");
              w.className = "element text-wrapper";
              Object.assign(w.style, {
                left: item.left,
                top: item.top,
                width: item.width,
                height: item.height,
              });
              const t = document.createElement("div");
              t.className = "text-content";
              t.contentEditable = true;
              t.innerText = item.text;
              Object.assign(t.style, {
                fontSize: item.fontSize + "px",
                color: item.color,
                textAlign: item.align,
                fontWeight: item.type === "title" ? "700" : "400",
              });
              w.append(t);
              paper.append(w);
              initElement(w, false, null);
            } else if (item.type === "sticker") {
              const w = document.createElement("div");
              w.className = "element image-wrapper";
              Object.assign(w.style, {
                left: item.left,
                top: item.top,
                width: item.width + "px",
                height: item.height + "px",
                fontSize: item.height * 0.8 + "px",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                transform: `rotate(${item.rotate || 0}deg)`,
              });
              w.textContent = item.sticker;
              paper.append(w);
              initElement(w, false, null);
            }
          });
        }
        templateItems.forEach((el) => {
          el.addEventListener("click", () =>
            applyTemplate(el.dataset.template)
          );
        });

        // IMAGE ASSETS
        assetAddBtn.addEventListener("click", () => {
          const url = assetUrlIn.value.trim();
          if (!url) return;
          const img = document.createElement("img");
          img.src = url;
          img.draggable = true;
          img.addEventListener("dragstart", (ev) =>
            ev.dataTransfer.setData("text/plain", url)
          );
          assetList.append(img);
          assetUrlIn.value = "";
        });

        // EMOJI DRAG
        emojiItems.forEach((em) => {
          em.draggable = true;
          em.addEventListener("dragstart", (ev) =>
            ev.dataTransfer.setData("text/plain", em.textContent)
          );
        });

        /* Helper functions */

        function rgbToHex(rgb) {
          const [r, g, b] = rgb.match(/\d+/g).map(Number);
          return (
            "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)
          );
        }
        function updateTextToolbarPosition(w) {
          const r = w.getBoundingClientRect(),
            tb = textToolbar.getBoundingClientRect();
          const cx = r.left + r.width / 2 + window.scrollX;
          let top = r.top + window.scrollY - tb.height - 8;
          if (top < window.scrollY + 8) top = r.bottom + window.scrollY + 8;
          textToolbar.style.left = cx + "px";
          textToolbar.style.top = top + "px";
          textToolbar.style.transform = "translateX(-50%)";
        }
        function updateShapeToolbarPosition(w) {
          const r = w.getBoundingClientRect(),
            tb = shapeToolbar.getBoundingClientRect();
          const cx = r.left + r.width / 2 + window.scrollX;
          let top = r.top + window.scrollY - tb.height - 8;
          if (top < window.scrollY + 8) top = r.bottom + window.scrollY + 8;
          shapeToolbar.style.left = cx + "px";
          shapeToolbar.style.top = top + "px";
          shapeToolbar.style.transform = "translateX(-50%)";
        }
        function deselect() {
          if (!selectedWrapper) return;
          selectedWrapper.classList.remove("selected");
          selectedWrapper = selectedContent = selectedPoly = null;
          textToolbar.style.display = shapeToolbar.style.display = "none";
        }
        function select(wrapper, content = null, poly = null) {
          if (selectedWrapper === wrapper) return;
          if (wrapper.classList.contains("image-wrapper")) {
            // images are handled separately: only show resize/rotate handles
            deselect();
            selectedWrapper = wrapper;
            wrapper.classList.add("selected");
            toolbar.style.display =
              shapeMenu.style.display =
              textToolbar.style.display =
              shapeToolbar.style.display =
              fontMenu.style.display =
                "none";
            return;
          }
          deselect();
          selectedWrapper = wrapper;
          selectedContent = content;
          selectedPoly = poly;
          wrapper.classList.add("selected");
          toolbar.style.display =
            shapeMenu.style.display =
            fontMenu.style.display =
              "none";
          if (content) {
            textToolbar.style.display = "flex";
            updateTextToolbarPosition(wrapper);
            document.getElementById("tbFontSize").value = parseInt(
              getComputedStyle(content).fontSize
            );
            document.getElementById("tbColor").value = rgbToHex(
              getComputedStyle(content).color
            );
          } else {
            shapeToolbar.style.display = "flex";
            updateShapeToolbarPosition(wrapper);
            const cs = getComputedStyle(wrapper);
            shapeFill.value = rgbToHex(cs.backgroundColor);
            shapeStroke.value = rgbToHex(cs.borderColor);
            shapeStW.value = parseInt(cs.borderWidth);
            shapeOp.value = cs.opacity;
          }
        }
        function initElement(wrapper, isTri, poly) {
          makeDraggable(wrapper);
          enableDrop(wrapper);
          addResizeHandles(wrapper);
          addRotateHandle(wrapper);
          if (isTri) makeTriangleResizable(wrapper, poly);
          wrapper.addEventListener("mousedown", (e) => {
            e.stopPropagation();
            select(wrapper, wrapper.querySelector(".text-content"), poly);
          });
          const content = wrapper.querySelector(".text-content");
          if (content) {
            content.addEventListener("dblclick", (e) => {
              e.stopPropagation();
              select(wrapper, content);
              content.focus();
            });
          }
          addToLayers(wrapper);
        }
        paper.addEventListener("dragover", (e) => e.preventDefault());
        paper.addEventListener("drop", (e) => {
          e.preventDefault();
          if (e.target !== paper) return;
          const data = e.dataTransfer.getData("text/plain");
          clickX = e.offsetX;
          clickY = e.offsetY;
          const wrap = document.createElement("div");
          wrap.className = "element image-wrapper";
          wrap.style.left = clickX + "px";
          wrap.style.top = clickY + "px";
          if (data.startsWith("http")) {
            wrap.style.backgroundImage = `url(${data})`;
            wrap.style.backgroundSize = "cover";
            wrap.style.backgroundPosition = "center";
            wrap.style.width = "100px";
            wrap.style.height = "100px";
          } else {
            wrap.textContent = data;
            wrap.style.fontSize = "40px";
            paper.append(wrap);
            const cw = wrap.clientWidth,
              ch = wrap.clientHeight,
              maxDim = Math.min(cw, ch);
            wrap.style.fontSize = Math.floor(maxDim * 0.9) + "px";
            wrap.style.width = cw + "px";
            wrap.style.height = ch + "px";
            wrap.remove();
          }
          paper.append(wrap);
          initElement(wrap, false, null);
          select(wrap, null);
        });
        function makeDraggable(el) {
          let startX, startY, origLeft, origTop;

          el.addEventListener("mousedown", (e) => {
            // ignore dragging when clicking on handles
            if (e.target.matches(".resize-handle, .vertex-handle, .rotate-handle")) return;
            e.preventDefault();

            // record starting mouse and element positions
            startX = e.clientX;
            startY = e.clientY;
            // parse current left/top as numbers (px)
            origLeft = parseFloat(el.style.left) || 0;
            origTop = parseFloat(el.style.top) || 0;

            const doMove = (ev) => {
              // compute new position
              const dx = ev.clientX - startX;
              const dy = ev.clientY - startY;
              el.style.left = origLeft + dx + "px";
              el.style.top = origTop + dy + "px";
              // update toolbar position if selected
              if (selectedWrapper === el) {
                if (selectedContent) updateTextToolbarPosition(el);
                else updateShapeToolbarPosition(el);
              }
            };

            document.addEventListener("mousemove", doMove);
            document.addEventListener("mouseup", () => {
              document.removeEventListener("mousemove", doMove);
            }, { once: true });
          });
        }
        function enableDrop(el) {
          el.addEventListener("dragover", (e) => e.preventDefault());
          el.addEventListener("drop", (e) => {
            e.preventDefault();
            const url = e.dataTransfer.getData("text/plain");
            if (!url) return;
            el.style.backgroundImage = `url(${url})`;
            el.style.backgroundSize = "cover";
            el.style.backgroundPosition = "center";
            // only bump true image-wrapper elements to the front
            if (el.classList.contains("image-wrapper")) {
              el.style.zIndex = "999";
            }
            if (el.classList.contains("shape-wrapper")) {
              const poly = el.querySelector("polygon");
              poly.setAttribute("fill", "none");
              poly.style.pointerEvents = "none";
              const pts = poly
                .getAttribute("points")
                .split(" ")
                .map((p) => p.split(",").map(Number));
              const W = el.clientWidth,
                H = el.clientHeight;
              const pct = pts
                .map(
                  ([x, y]) =>
                    `${((x / W) * 100).toFixed(1)}% ${((y / H) * 100).toFixed(
                      1
                    )}%`
                )
                .join(", ");
              el.style.clipPath = `polygon(${pct})`;
            }
            // update the corresponding Layers list icon for this wrapper
            document
              .querySelectorAll("#layersList .layerItem")
              .forEach((li) => {
                if (li._wrapper === el) {
                  // remove old icon element
                  const oldIcon = li.querySelector(".layerIcon, img");
                  // create new icon: img if background-image exists
                  let newIcon;
                  const bg = el.style.backgroundImage;
                  const m = bg.match(/^url\("?(.+?)"?\)$/);
                  if (m && m[1]) {
                    newIcon = document.createElement("img");
                    newIcon.src = m[1];
                    newIcon.className = "layerIcon";
                  } else {
                    // fallback to scaled clone for shapes without bg image
                    newIcon = document.createElement("div");
                    newIcon.className = "layerIcon";
                    newIcon.style.overflow = "hidden";
                    newIcon.style.position = "relative";
                    const clone = el.cloneNode(true);
                    clone.style.position = "static";
                    clone.style.left = "0";
                    clone.style.top = "0";
                    clone.style.margin = "0";
                    clone.style.pointerEvents = "none";
                    const scale =
                      24 / Math.max(el.offsetWidth, el.offsetHeight);
                    clone.style.transform = `scale(${scale})`;
                    clone.style.transformOrigin = "top left";
                    newIcon.appendChild(clone);
                  }
                  li.replaceChild(newIcon, oldIcon);
                }
              });
          });
        }
        function addResizeHandles(el) {
          ["nw", "ne", "sw", "se"].forEach((dir) => {
            const h = document.createElement("div");
            h.className = "resize-handle handle-" + dir;
            el.append(h);
            h.addEventListener("mousedown", startResize(dir, el));
          });
        }
        function startResize(dir, el) {
          return function (e) {
            e.stopPropagation();
            e.preventDefault();
            const r = el.getBoundingClientRect(),
              pr = paper.getBoundingClientRect();
            const start = {
              x: e.clientX,
              y: e.clientY,
              left: r.left - pr.left,
              top: r.top - pr.top,
              w: r.width,
              h: r.height,
              aspect: r.width / r.height,
            };
            document.addEventListener("mousemove", doResize);
            document.addEventListener(
              "mouseup",
              () => document.removeEventListener("mousemove", doResize),
              { once: true }
            );
            function doResize(ev) {
              let dx = ev.clientX - start.x,
                dy = ev.clientY - start.y;
              let newW = start.w,
                newH = start.h,
                newL = start.left,
                newT = start.top;
              if (dir.includes("e")) newW = start.w + dx;
              if (dir.includes("s")) newH = start.h + dy;
              if (dir.includes("w")) {
                newW = start.w - dx;
                newL = start.left + dx;
              }
              if (dir.includes("n")) {
                newH = start.h - dy;
                newT = start.top + dy;
              }
              if (el.classList.contains("image-wrapper") || ev.shiftKey) {
                newH = newW / start.aspect;
                if (dir.includes("n")) newT = start.top + (start.h - newH);
              }
              el.style.width = newW + "px";
              el.style.height = newH + "px";
              el.style.left = newL + "px";
              el.style.top = newT + "px";
              if (
                el.classList.contains("image-wrapper") &&
                !el.style.backgroundImage
              ) {
                const maxDim = Math.min(newW, newH);
                el.style.fontSize = Math.floor(maxDim * 0.8) + "px";
              }
              if (selectedWrapper === el) {
                selectedContent
                  ? updateTextToolbarPosition(el)
                  : updateShapeToolbarPosition(el);
              }
            }
          };
        }
        function addRotateHandle(el) {
          const h = document.createElement("div");
          h.className = "rotate-handle";
          el.append(h);
          h.addEventListener("mousedown", (e) => {
            e.stopPropagation();
            e.preventDefault();
            const rect = el.getBoundingClientRect(),
              cx = rect.left + rect.width / 2,
              cy = rect.top + rect.height / 2,
              startAng = Math.atan2(e.clientY - cy, e.clientX - cx),
              currRot = parseFloat(el.dataset.rot || 0);
            function onmove(ev) {
              const ang = Math.atan2(ev.clientY - cy, ev.clientX - cx),
                delta = ang - startAng,
                deg = currRot + (delta * 180) / Math.PI;
              el.style.transform = `rotate(${deg}deg)`;
              el.dataset.rot = deg;
              if (selectedWrapper === el) {
                selectedContent
                  ? updateTextToolbarPosition(el)
                  : updateShapeToolbarPosition(el);
              }
            }
            document.addEventListener("mousemove", onmove);
            document.addEventListener(
              "mouseup",
              () => document.removeEventListener("mousemove", onmove),
              { once: true }
            );
          });
        }
        function makeTriangleResizable(wrap, poly) {
          let pts = [
            [0, 70],
            [40, 0],
            [80, 70],
          ];
          const handles = pts.map((_, i) => {
            const h = document.createElement("div");
            h.className = "vertex-handle";
            wrap.append(h);
            return h;
          });
          function update() {
            handles.forEach((h, i) => {
              h.style.left = pts[i][0] + "px";
              h.style.top = pts[i][1] + "px";
            });
            poly.setAttribute("points", pts.map((p) => p.join(",")).join(" "));
          }
          handles.forEach((h, i) => {
            h.addEventListener("mousedown", (e) => {
              e.stopPropagation();
              e.preventDefault();
              select(wrap, null, poly);
              const start = {
                x: e.clientX,
                y: e.clientY,
                wrapL: wrap.offsetLeft,
                wrapT: wrap.offsetTop,
                pts: pts.map((p) => p.slice()),
              };
              function ondrag(ev) {
                const dx = ev.clientX - start.x,
                  dy = ev.clientY - start.y;
                const abs = start.pts.map((p, j) =>
                  j === i ? [p[0] + dx, p[1] + dy] : p
                );
                const xs = abs.map((p) => p[0]),
                  ys = abs.map((p) => p[1]),
                  minX = Math.min(...xs),
                  minY = Math.min(...ys),
                  maxX = Math.max(...xs),
                  maxY = Math.max(...ys);
                pts = abs.map((p) => [p[0] - minX, p[1] - minY]);
                wrap.style.left = start.wrapL + minX + "px";
                wrap.style.top = start.wrapT + minY + "px";
                wrap.style.width = maxX - minX + "px";
                wrap.style.height = maxY - minY + "px";
                update();
              }
              document.addEventListener("mousemove", ondrag);
              document.addEventListener(
                "mouseup",
                () => document.removeEventListener("mousemove", ondrag),
                { once: true }
              );
            });
          });
          update();
        }

        // Insert buttons
        document.getElementById("btnText").addEventListener("click", (e) => {
          e.stopPropagation();
          const wrap = document.createElement("div");
          wrap.className = "element text-wrapper";
          wrap.style.left = clickX + "px";
          wrap.style.top = clickY + "px";
          wrap.style.width = "150px";
          wrap.style.height = "80px";
          const txt = document.createElement("div");
          txt.className = "text-content";
          txt.contentEditable = true;
          txt.innerText = "Enter text";
          wrap.append(txt);
          paper.append(wrap);
          initElement(wrap, false, null);
          select(wrap, txt);
          txt.focus();
        });
        document.getElementById("btnShape").addEventListener("click", (e) => {
          e.stopPropagation();
          const r = e.currentTarget.getBoundingClientRect();
          shapeMenu.style.left = r.right + 8 + "px";
          shapeMenu.style.top = r.top + "px";
          shapeMenu.style.display = "flex";
        });
        shapeMenu.addEventListener("click", (e) => {
          const b = e.target.closest("[data-shape]");
          if (!b) return;
          shapeMenu.style.display = "none";
          const type = b.dataset.shape;
          if (type === "rect" || type === "circle") {
            const wrap = document.createElement("div");
            wrap.className =
              "element " + (type === "rect" ? "shape-rect" : "shape-circle");
            wrap.style.left = clickX + "px";
            wrap.style.top = clickY + "px";
            wrap.style.width = "100px";
            wrap.style.height = "100px";
            // Default fill and border so the shape shows immediately
            wrap.style.backgroundColor = "#A8E6CF";
            wrap.style.border = "2px solid #82C9A1";
            paper.append(wrap);
            initElement(wrap, false, null);
            select(wrap, null);
          } else {
            // triangle
            const wrap = document.createElement("div"),
              ns = "http://www.w3.org/2000/svg";
            wrap.className = "shape-wrapper";
            wrap.style.left = clickX + "px";
            wrap.style.top = clickY + "px";
            wrap.style.width = "100px";
            wrap.style.height = "80px";
            const svg = document.createElementNS(ns, "svg"),
              poly = document.createElementNS(ns, "polygon");
            svg.setAttribute("width", "100%");
            svg.setAttribute("height", "100%");
            poly.setAttribute("points", "0,80 50,0 100,80");
            poly.setAttribute("fill", "#A8E6CF");
            poly.setAttribute("stroke", "#82C9A1");
            poly.setAttribute("stroke-width", "2");
            svg.append(poly);
            wrap.append(svg);
            paper.append(wrap);
            initElement(wrap, true, poly);
            select(wrap, null, poly);
          }
        });

        // Paper click → show toolbar
        paper.addEventListener("mousedown", (e) => {
          if (
            e.target.closest(
              "#toolbar,#shapeMenu,#textToolbar,#shapeToolbar,#fontMenu"
            ) ||
            e.target !== paper
          )
            return;
          deselect();
          clickX = e.offsetX;
          clickY = e.offsetY;
          const tb = toolbar.getBoundingClientRect();
          let left = e.clientX + window.scrollX - tb.width / 2,
            top = e.clientY + window.scrollY - tb.height - 8;
          if (top < window.scrollY + 8) top = e.clientY + window.scrollY + 8;
          toolbar.style.left = left + "px";
          toolbar.style.top = top + "px";
          toolbar.style.display = "flex";
        });

        // Hide on outside
        ["mousedown", "touchstart"].forEach((evt) => {
          document.addEventListener(evt, (e) => {
            if (e.target === paper) return;
            if (
              e.target.closest(
                "#toolbar,#shapeMenu,#textToolbar,#shapeToolbar,#fontMenu"
              )
            )
              return;
            toolbar.style.display =
              shapeMenu.style.display =
              textToolbar.style.display =
              shapeToolbar.style.display =
              fontMenu.style.display =
                "none";
          });
        });
        [toolbar, shapeMenu, textToolbar, shapeToolbar, fontMenu].forEach(
          (el) => {
            el.addEventListener("mousedown", (e) => e.stopPropagation());
            el.addEventListener("touchstart", (e) => e.stopPropagation());
          }
        );

        // Text toolbar actions
        document.getElementById("tbBold").onclick = () =>
          selectedContent &&
          (selectedContent.style.fontWeight =
            selectedContent.style.fontWeight === "bold" ? "" : "bold");
        document.getElementById("tbItalic").onclick = () =>
          selectedContent &&
          (selectedContent.style.fontStyle =
            selectedContent.style.fontStyle === "italic" ? "" : "italic");
        document.getElementById("tbUnderline").onclick = () =>
          selectedContent &&
          (selectedContent.style.textDecoration =
            selectedContent.style.textDecoration === "underline"
              ? ""
              : "underline");
        document.getElementById("tbAlignLeft").onclick = () =>
          selectedContent && (selectedContent.style.textAlign = "left");
        document.getElementById("tbAlignCenter").onclick = () =>
          selectedContent && (selectedContent.style.textAlign = "center");
        document.getElementById("tbAlignRight").onclick = () =>
          selectedContent && (selectedContent.style.textAlign = "right");
        document
          .getElementById("tbFontSize")
          .addEventListener(
            "input",
            (e) =>
              selectedContent &&
              (selectedContent.style.fontSize = e.target.value + "px")
          );
        document
          .getElementById("tbColor")
          .addEventListener(
            "input",
            (e) =>
              selectedContent && (selectedContent.style.color = e.target.value)
          );
        tbDeleteText.addEventListener("click", () => {
          if (selectedWrapper) {
            // remove corresponding layer item
            document
              .querySelectorAll("#layersList .layerItem")
              .forEach((li) => {
                if (li._wrapper === selectedWrapper) li.remove();
              });
            selectedWrapper.remove();
            deselect();
          }
        });

        // Font menu
        document.getElementById("tbFont").addEventListener("click", (e) => {
          e.stopPropagation();
          fontMenu.style.display =
            fontMenu.style.display === "block" ? "none" : "block";
        });
        fontOpts.forEach((btn) =>
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (selectedContent)
              selectedContent.style.fontFamily = `'${btn.dataset.font}',sans-serif`;
            fontMenu.style.display = "none";
          })
        );

        // Shape toolbar actions
        shapeFill.addEventListener("input", (e) => {
          if (selectedWrapper) {
            if (selectedPoly) selectedPoly.setAttribute("fill", e.target.value);
            else selectedWrapper.style.backgroundColor = e.target.value;
          }
        });
        shapeStroke.addEventListener("input", (e) => {
          if (selectedWrapper) {
            if (selectedPoly)
              selectedPoly.setAttribute("stroke", e.target.value);
            else {
              const dash = selectedWrapper.style.border.includes("dashed")
                ? "dashed"
                : "solid";
              selectedWrapper.style.border = `${shapeStW.value}px ${dash} ${e.target.value}`;
            }
          }
        });
        shapeStW.addEventListener("input", (e) => {
          const v = e.target.value;
          if (selectedWrapper) {
            if (selectedPoly) selectedPoly.setAttribute("stroke-width", v);
            else {
              const dash = selectedWrapper.style.border.includes("dashed")
                ? "dashed"
                : "solid";
              selectedWrapper.style.border = `${v}px ${dash} ${shapeStroke.value}`;
            }
          }
        });
        shapeOp.addEventListener("input", (e) => {
          if (selectedWrapper) selectedWrapper.style.opacity = e.target.value;
        });
        tbDeleteShape.addEventListener("click", () => {
          if (selectedWrapper) {
            // remove corresponding layer item
            document
              .querySelectorAll("#layersList .layerItem")
              .forEach((li) => {
                if (li._wrapper === selectedWrapper) li.remove();
              });
            selectedWrapper.remove();
            deselect();
          }
        });

        // Delete key
        document.addEventListener("keydown", (e) => {
          if (e.key === "Delete" && selectedWrapper) {
            // remove corresponding layer item
            document
              .querySelectorAll("#layersList .layerItem")
              .forEach((li) => {
                if (li._wrapper === selectedWrapper) li.remove();
              });
            selectedWrapper.remove();
            deselect();
          }
        });

        // -- Layers panel logic --
        const layersList = document.getElementById("layersList");
        function addToLayers(wrapper) {
          const li = document.createElement("li");
          // keep reference for reordering
          li._wrapper = wrapper;
          li.className = "layerItem";
          li.draggable = true;
          // create a mini-icon: real <img> for images, clone otherwise
          let icon;
          if (wrapper.classList.contains("image-wrapper")) {
            // detect real images vs. stickers/text
            const bg = getComputedStyle(wrapper).backgroundImage;
            const m = bg.match(/^url\("?(.+?)"?\)$/);
            if (m && m[1]) {
              icon = document.createElement("img");
              icon.src = m[1];
              icon.className = "layerIcon";
            } else if (wrapper.textContent.trim()) {
              // sticker (emoji) preview
              icon = document.createElement("div");
              icon.className = "layerIcon";
              icon.style.fontSize = "16px";
              icon.style.lineHeight = "16px";
              icon.style.textAlign = "center";
              icon.textContent = wrapper.textContent.trim();
            } else {
              // fallback to blank icon
              icon = document.createElement("div");
              icon.className = "layerIcon";
            }
          } else {
            icon = document.createElement("div");
            icon.className = "layerIcon";
            icon.style.overflow = "hidden";
            icon.style.position = "relative";
            // clone the element for mini-preview
            const clone = wrapper.cloneNode(true);
            // remove top padding so text is visible
            clone
              .querySelectorAll(".text-content")
              .forEach((el) => (el.style.paddingTop = "0"));
            clone.style.position = "static";
            clone.style.left = "0";
            clone.style.top = "0";
            clone.style.margin = "0";
            clone.style.pointerEvents = "none";
            // scale to fit a 24×24 box
            const scale =
              24 / Math.max(wrapper.offsetWidth, wrapper.offsetHeight);
            clone.style.transform = `scale(${scale})`;
            clone.style.transformOrigin = "top left";
            icon.appendChild(clone);
          }
          const label = document.createElement("span");
          label.className = "layerLabel";
          label.textContent = wrapper.classList.contains("text-wrapper")
            ? "Text"
            : wrapper.classList.contains("shape-rect")
            ? "Rect"
            : wrapper.classList.contains("shape-circle")
            ? "Circle"
            : wrapper.classList.contains("shape-wrapper")
            ? "Triangle"
            : "Image";
          li.append(icon, label);
          layersList.prepend(li);

          // Drag & drop to reorder
          li.addEventListener("dragstart", (e) => {
            li.classList.add("dragging");
            e.dataTransfer.setData("text/plain", "");
          });
          li.addEventListener("dragend", () => li.classList.remove("dragging"));

          layersList.addEventListener("dragover", (e) => {
            e.preventDefault();
            const dragging = layersList.querySelector(".dragging");
            const after = [
              ...layersList.querySelectorAll(".layerItem:not(.dragging)"),
            ].find(
              (item) =>
                e.clientY <
                item.getBoundingClientRect().top + item.offsetHeight / 2
            );
            if (after) layersList.insertBefore(dragging, after);
            else layersList.append(dragging);
          });
        }

        // Whenever the layers list changes order, reflow the canvas
        layersList.addEventListener("drop", () => {
          // on drop, reorder DOM per li._wrapper references
          // pop the list order: first list item is top layer, so reverse for stacking
          const items = Array.from(layersList.children).reverse();
          items.forEach((li) => {
            const wrapper = li._wrapper;
            if (wrapper) paper.appendChild(wrapper);
          });
        });
      })();
    </script>
  </body>
</html>
